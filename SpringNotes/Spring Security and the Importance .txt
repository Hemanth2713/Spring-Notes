**Spring Security and the Importance of Security**

When you build an application, what's the most important thing which comes to your mind? I know according to this topic it should be security. But as a developer, the most important thing for us the project should work, right? So whatever code you write should work is our first thing. And then of course your code should work. If your client is accessing your application, it should work, right? Otherwise why someone will use an the application. So that's first thing. Second, we need to make sure that your application is stable. So let's say in your project you have ten features and then you want them to work. Of course you will test your application by doing that and doing the doing this. If everything works fine you are confident that it will work, but then will it work every time? That's a question. So you want to make your application stable so it doesn't matter what kind of input your user gives. You have to handle those exceptions. And we have talked about exceptions before. Right. So basically we have to make sure as a developer that you handle the exceptions, you make sure that your application is stable. So even if you have a lot of users, you have to make sure that your application is scalable as well. Uh, maybe that's a part of cloud deployment. You can scale your cloud applications and stuff, but the important thing is your code should work and it should be stable. The next important thing to look at is performance. Of course right. Nowadays we don't have patience as a user. We don't have patience. Right. When you go to any application, doesn't matter. Is it our e-commerce website or our social media website or it is our enterprise application? We want speed. Basically we want the result in less amount of time. So we have to make sure that your application has a good performance, not just one feature. Everything should be on the same page. We tend to make some features faster and then because of some complex behavior, some of the features lag. But then we try to focus that everything goes smoothly. So the thing is the application should work, the application should be stable. And also we need performance. But what about security? See the thing is as a developer we have this mindset that security is not our concern. Because when you build an application and if it's an enterprise application, of course we have a separate team who will provide the security for your project. Now, when you talk about security, what comes to your mind? Maybe there are some attackers attacking your application, and the way you secure them is with the help of firewalls, some or some policies which you set who can use this application, but then it goes beyond that. One of the example you can say is login password. So of course, whenever you go to any website where the data should be secured, we do get their username and password right. So we have to consider that part. So if a user comes to your application by saying hey I am Naveen, how do you prove yourself that you're Naveen? Next, what are the roles you have? So we take care of those things, right? So the question is how will you implement security in terms of authentication. In terms of authorization is not just about username password. It's also about what features you can access. For example, if you talk about our application which is job application, it is working. I'm not sure if it is stable because we have not done exception handling. I'm not sure if it has good performances because we have not done any scalable, scalable code there. But how about security? Anyone can add a job, anyone can delete a job. Anyone can basically search a job. Don't you think different users should have a different access? Example. If you are creating a new job, we have to make sure that you are the admin. Not a normal user should not be able to create a job there. And if you are deleting a job or any if you're doing any changes to the application, we have to check the access. The authorization is also important, but is it the only two things important? Not exactly. See, if we talk about security, there are a lot of different things. And hackers or someone who wants to attack your application, they are much ahead in terms of what are the security vulnerabilities we have, how they can attack your application. So you have to basically take care of everything, even if you have a small loophole. So let's say you build an application, you try to secure it, but there will be one simple loophole, and the attackers are going to attack exactly at that place. And because of that loophole, the application can be hacked. Okay. So you have to make sure that we secure it. And the question arises what level of security we have to go to see. There are different kinds of application, right. We have applications which manages your data. In fact, we have some application where they don't manage your data. They manage their own data, which can be public. So if you have a public website, everything is public. In that case, security is important, but then not that much. But what if you are basically handling user personal data? Now that's critical. If you are handling user credit card information now, that's critical. You are handling user medical records. Now that's critical. If you're handling users money something like a banking application, that's very, very critical because that's a human tendency, right? We care more about money than your personal data, but your personal data is also important. I mean, think about this if someone hacks your credit card. So let's say if a company announced, hey, you know, uh, there's an attack on the website or the, on the application and millions of credit card information has been leaked, you will be concerned, but then you can also block your credit cards, right. So the moment I get this message, I can block my credit card. What about if someone hacks your bank account? Maybe they withdraw some money, but then you can block your bank account as well. What about your medical records or personal data? Once it is gone, it's gone. Okay, maybe privacy is not important to you, but it's important for most of us. So you have to make sure that we handle the data as well. So according to some rules and regulations, personal data is also important. So if you leak those data I mean not on purpose, but let's say if there's an attack on the user data which you are handling, you have to pay high penalty. Or you may you might have to go to jail as well. So that's something you have to take care of. So personal data is very very important. But now question arise. How do you know. How do you secure your application. What are the attacks we have. And that's where we have something called OWASp top ten, in which you will see the top ten attacks which are happening. And you can take care of it. But what exactly OWASp is and what is the those top ten security risk? Let's talk about that in the next video. And one more thing now, since we're talking about all the security in this topic of security, does it handle, uh, most of the most of the security issues? And the answer is yes.

**OWASP Top 10**

So before jumping into spring security, let's talk about the top ten security risks. Now to understand this, we have a place where we can see the top ten security risks. Now, when you say top ten is not the only ten, we have a lot of security risks which have to take care of. But then these are top ten. At least solve this problem first. Now to create this top ten we got something called a OWASp. Now if you see the full form of OWASp it's a open web application security project. In short, a Wasp. And they create this top ten every four years. So last time they did is in 2021. And before that it was 2017 and now expecting it to run 25. So till that we have to go for this top ten. And of course I want you to be updated. So if you're watching this video after a few years, make sure that you check the list at that time. Now if you look at this list, of course, when we go to the topic of spring security, we'll talk about each of one of them, which one we're trying to solve. But then, of course, we may not be looking at all the security risks here, but then we'll see what are the things which we can solve in spring security. Okay. So let's talk about the first one. So you can see we have top ten. We got the first one which is broken access control. If you want to read more about this you can click here. On the new tab they will give you a description. Now basically this this talks about the access control. Remember when we talked about authentication and authorization. So as a user what are the resources I can access. What are the resources I can modify. So all this controls if those are broken then it's a security risk. Now of course if you can just read this it will give you more idea. I will share the link in the resources as well for this website and it will. It gives you the introduction for access control. The next one we have is cryptographic failure. Now cryptography becomes a very important thing in security is because whatever data you send from server to client, from client to server need to be secured. So let's say if a server is basically secured by saying, hey, no one other than the actual users can access this data, but the data is getting passed from the server to client, right? If you are not encrypting it, then anyone can basically attack, which is a man in the middle attack and they can read data. But now let's say you say, hey, you know, I'm using encryption there. But the question is the encryption technique, which you're using, is it secure. So not every encryption technique is secure. So you have to check which one is secure and which one is not, which is the latest standard. And if you're going for one way encryption which is hashing basically. So we have different techniques for hashing techniques. We have MD5 and Sha and those are deprecated. So are you still using them? So that's something you have to take care of when you are building an application or when you're securing an application. Next interesting one we have is injection. Now basically your application can be hacked. Now when you say application here we can talk about Dexter application as well. But the security becomes important when it is a web application because anyone from the world can access it. Dexter application can be you can secure your desktop application by securing your door. Right. No one can come in And then how can they access the desktop application? But what about web application? Anyone can access it from all over the world. And to secure it, of course, we have to maintain the security, but then even then they can hack with the help of injections. Now let me give an example here. When you talk about SQL. So let's say we use JDBC. We have talked about JDBC. And then when you want to let's say search something from the table. Of course you find a Select query. Right now Now when you say select star from a table, basically you get everything. But then most of the time we pass the values as well based on which you want to filter. So you will apply a Where clause in the Where clause. You will say, okay, I have this data. But then if you want to use a normal statement in JDBC, what we do is we use a query and then we pass the values at the end by doing plus and then single quote a lengthy string. But you pass the value there. So let's say if you go to a website and say my name is Naveen, my password is this. If you are a real user, of course you will get the access if you're not a real user. If you're an attacker, you don't have your username password in the database. It will not allow you, right? So what do you think? What will be the query for this? Of course you can simply say select star from table where the username is this where the password is. This important thing is if this query fires and if you give, it gives you any row that means the user is valid. But what if you don't receive any rows? That means the user is invalid. So ultimately it's all about true and false right? So what if as a user or as an attacker, I'm passing a username as Naveen and by saying Naveen or one is equal to one where clause says one is equal to one, Let me return true or let me return some rows. So basically it's all comes down to and false. And that's a SQL injection. And one way to prevent it is with the help of prepared statement. Because in prepare statement we takes the value with the type. That's how you can basically, uh, secure it. But then SQL is not the only injection we have. We have different injections as well. We got no SQL injection OS commands. Uh, we got for ARM as well. And uh, with with the graph as well. So there are different types of injection attack which can happen and you have to take care of it. Uh, next is about how you are designing your application. It's not about implementation but design how well you're designing your application. Is it secure? Uh, next we have is security misconfiguration. Uh, see, whenever you use any particular library or a server or a framework or a tool, basically most of these tools, frameworks and libraries gives you a default configuration, and sometimes we don't change them. And since its default configuration, everyone knows about those configuration. So as an attacker, simply I can if I know which tool you are using, which server you are using. Basically, I can just go there and I can hack with the default configuration. Even if you have used ten tools in your project and you have secured and you have changed the configuration for the nine Nine tools. That one tool will create mess for your project. So you have to make sure that you change the configurations. Next is vulnerable and outdated components. We do have this tendency of using external tools, let's say DBMs or a library. And if they are deprecated, if they are not supported by the company itself, don't use them. If they are not in support, if they don't get security updates, it can also lead to attacks. Then we have authentication failures with the username passwords. We do have a tendency of storing the passwords directly in the database. I used to do that in my first initial projects, and then I realized not a good idea, right? So you have to always make sure that you encrypt your password when you want to store in the database, not two way encryption. Basically, once you store the password in the database, no one should be able to decrypt it. So hashing works there. So that's something we can use. Also missing the multifactor authentication. So don't just go with one auto authentication example. Most of the websites now they ask you for username password but they also send you SMS to verify. They also send you app notification to verify. So you can have a multi layered or multi factor authentication enabled. And then we have more security issues here regarding the data integrity. Then we have logging as well. Now this is interesting is because we all log our activities on the website, right? So we we do write the log statements and we have seen that in AOP as well. Every time you call a function maintain the log. But there's one issue with the log. In fact there are two issues. The first issue is most of the people avoid logging is because it affects your performance, especially if it is a performance critical application. So we skip the log statements. But the problem is, if someone is attacking your application, how will we know that there's an attack? So if you have a log maintained properly, you can actually read the logs. But it also creates a second problem. The problem is if you have a log, there are thousands of activities going on at the same time, right? And if you have a log for everything, how will you know which one is a security risk or which one is a security attack which is happening. So you have to make sure that you maintain your log properly and observe your logs, which is very important. Don't don't just wait for the attack to happen. Then you will say, hey, you know, let's check the logs, keep monitoring your logs. It will reveal how many attacks are going on. And also we have a server side request forgery. Uh, in fact, there were two more before. But then because of the ranking, it changed. There was client side scripting, but also now we have server side request forgery. What if you are sending some data from server to client and the data itself is malicious, which is you are sending from the server to client. So basically you are getting your client in risk. So we have to mitigate all these things. And as I mentioned before, these are not the only risk we have. We have lot of risk. But these are top ten. And I would encourage you to go through this top ten once again. Read it and you will get more idea on it. Now let's see how exactly we can implement that with spring security. And is it easy to implement or is it difficult?

**Creating a Security Project**

The thing is, we'll be implementing security on our job portal later. Let's try to create a fresh project. Let's try to see how do we implement spring security, what are the other options we have. And then we'll try to secure our job application. So what we're going to do is the first thing you will do is you will go back to your browser and open the spring supervisor. And here we'll create a project, a fresh project. We'll say this is a maven project Java language. The spring boot version I'm using, which is 3.2.2 and the group ID is comm.co, the project name I will give as spring seq demo and the packaging. I will keep it as jar. The Java version I'm using is Java 21 and let's add dependency. Now this is. This will be interesting is because we are creating a web application of course. Right. You want to secure your web application. So we'll add a first web because we want to get a web project. And then for security I will use a spring security. Also I want to use a dev tool which will help you to reload your application faster. You can also use this in the earlier project which we have used, but let's use it here also. Maybe we'll need the database, maybe we can add that later as well. At this point we are adding this three web Spring Security and dev tool. Click on generate. It will create a project. You just have to unzip it now okay. So once you unzip it you just have to open that in the IDE. So till this point I was using IntelliJ Idea community version. For this particular section I'm using. The ultimate version is because when you see the content or when you watch this video on ultimate version, you will get more clarity. That's the only time I'm using it. But you can run the same application on community version. It perfectly works or any other idea which you have. Eclipse VSCode. It works there. Okay, so I have a project ready here. So let's look at the project again. This is a simple spring boot project. If you expand mean you will find Java resources. You got only one file there. And when you open the pom.xml you can see we have multiple things here. We got spring web spring security dev tool. At this point what I will do is I will just comment this security part because I don't want to use it now, will try to introduce this bit later. So I'm commenting this. And basically in this project now we don't have security. We just have spring web and dev tool. So let's go back here and let's create a controller of course. Right. If you want to test if if your security is working for a web application, you need some resources which you want to secure. So in your application you could you can have public resources and you can have a secure resource. Now when you say public resource it can be your home page. If you're building a beautiful application using your own UI. Or maybe you want to, uh, if you even if you're building a rest API, you can send some data which is public. But then of course you can have data which are which are secured. Only you can access them only when you are logged in and you have the authorization to access it, or you are authorized to access it. So here let me create a resource and I will say Java class. Let me create a controller. And I will say this is a simple one. Hello controller. And I want this to be a Rest controller because I want to return a Rest data, not a page. Basically I want to return JSON. That's it. And in this I want to have a method. So let's say I want I'm going to say public string. I want to return a hello. That's it. And then I will say method name is greet open close. And here I will do the mapping. I will say this is for get mapping. And the request I want to send is hello. So whenever you send request for hello I want to display this. Or maybe you can do it for the home page as well. But let's at this point I'm just saying for hello, I will say return and I want to print Hello world. Okay. That's it. Nothing fancy, just want to print Hello World. And now let's run this. If let's see if this works. What I will do is I will go back to my application and said run. So you can see it is running on Tomcat 800 or Tomcat port eight 800. I need to reload this so you know when I committed this. This is something you have to remember whenever you change anything in the Pom file, uh, reload your Maven configuration and then restart the application because I forgot to reload the maven configuration. And let's go back to the browser. And now let's hit 8080. You can see we got the error because we haven't done nothing for the home page. The page we want to request is slash. Hello. When I say enter we got Hello world. So basically anyone can access this page, right? I want I don't want it. I want people to log in to access this page. So that means we have to create a login form. And the way you can do that is by enabling spring security. So basically I want to protect this resource. And to do that we have to enable this security. That means we have to also create a login form okay lengthy Lengthy work. Right. So let's do that in the next video where we'll try to create this login form. And maybe we have to also create this. When you create this form the username should be plain text but the password should be encoded right. So we have to change that as well. And then we have to send that username password on the back end to verify. And someone I mean we have to write a code for that as well to verify the username password. So maybe next video will be a bit lengthy.

**Default Login Form**

So now let's create those login form, verify the username password then the steps right. But first step is to basically uncomment this thing because I want to use spring security now and let me reload my mavin. That's the only thing I'm doing now. And let's restart the application. Let's see what happens. So I'm restarting the application. And now when I go back to my page of course we don't have a login form. Let's try to do that login form later. So basically we have to get a login form. We have to verify the username password. We have to maybe you have to create a service layer. Let's see that. Let's do step by step. What I will do is let's go back to my browser. And this time also I will hit the same URL which is localhost colon 8080 slash. Hello. Enter. Oh that's weird. We got a login form. Now if you are thinking maybe between this two videos, I have changed the the change the code. Maybe I have created a login form with this beautiful UI. Okay, I'm not sure if this works. We'll see that later. But let me show you something. If I go back to the code, look at the number of files we have. We only have two classes here. We got hello controller and you can see hello controller still returns. Hello. There is no method here to call this page. And even if you see the resources, we don't have any page here. So from where exactly we got this page. And that's the beauty of spring security. The moment you add the dependency, which is the spring security dependency, it will create a page for you. That's we got also, we don't have to write any logic to verify username password. We can simply go back and enter the username password. It will work. But the question is I don't know what's the username password is. So the username is something which is by default which is user. So it doesn't matter how many times you use spring boot security, the default username is user. What about the password? Do we have any default passwords? Again, not a good idea, right? Having a default password. But where I where I will get the password. Let's go back to the IDE. And if you scroll so in the console if you scroll up up up up up. Yep. Here can you see that it says using generated security password. This is the password. So basically they have used the auto config where it generates a password for you. And this is the password. And this password will be different for everyone. So when you try this you will get different password I can simply copy this password and paste here and click on sign in. Boom. You see that we got the output right. So it is also verifying the username password. Maybe you're thinking even if I enter any password it will work. Let's try. So what I will do is I will I will just relaunch this. This time will have a different password of course. And if I go back to my browser hit refresh okay. Still the session is there. Okay. So there's a cache. So what I will do is I will just open a private window. And now I'm hitting for the localhost 8080. And I will even say say hello here. And you can see it is asking for username password I will say user. and okay I will say user one. And even in the in the password I will change something. I will just remove the one character, click on sign in and you can see it says bad credentials. So we do have to enter the right username and password. Click on sign in. Oh okay. So maybe I'm entering the older passwords copy and user paste enter. And you can see we are able to access it also what about the logout? What I will do is uh let's type logout here. Enter. You can see we got a logout page as well where it says are you sure you want to log out. Yes I want to log out. Done. And now if you try to access you know this was this is what happened in the previous, uh, window, browser window. My session was created. So I was able to access the same page again. But now if you say hello, it will ask you to log in again because you have logged out and all this basic feature you got just by adding one dependency, I mean, imagine the amount of time you are saving and not just one resource there. It doesn't matter in your application how many resources you have. Maybe you have hello resource. I mean, the resource I'm talking about is this. So we got hello here. Maybe you have multiple controllers, multiple methods. It will secure everything okay by default just by adding that dependency. So what's happened behind the scene is if you go back to the topic of spring MVC, we have talked about different layers, right. We have a client. Client sends request to the server. But for all the controllers in your server you will be having a front controller which is called a servlet. So request goes from the client to the server despite servlet send request to the particular controller. But even before your dispatcherservlet the moment you add spring security, it adds one more layer of spring security. And inside this layer you'll be having multiple filters. Let's talk about those filters in the next video. Okay. But then you'll be having filters which will verify should we send this request to the next path which is your dispatch servlet. Okay. So let's discuss more about filters in the upcoming videos.

**Spring Security Filters**

Now let's talk about the filters. So as I mentioned before, the moment you add spring security in your project, basically all the requests, it will first go to spring security. And then it verifies for all the authentication authorization. If it is yes, then only it will the request go to dispatch servlet. Now what are the filters we have by default. Now spring security works with multiple filters. And we are not going to use all. But let's use the major one. Now how do you know which filters are applied? Now? If you see your console just after your password and you can see this, it says this password. This generated password is for development use only. Your security configuration must be updated before running the application in production. That's right. You don't want this password to be there for your application. For production, you have to use something else. Additionally, you only got one username password. Of course your application will be having multiple users we have not seen. How do we do that? How do you have multiple username and password? We'll see that in the upcoming videos. But we have to change it. Okay. Let's look at the filters we have. And there's a concept of filter change. Now this is not a new concept for spring. We when you talk about servlet we also got servlet filters there. Now just to give you a basic idea, let's say you you're not using Spring Framework. You're using servlet. So the request goes from the client to servlet. And let's say if you want to add two numbers your client will say hey I have this two numbers, two plus three added. So it says okay two plus three is five. Get the data back. It works. Right. But what if you want to check if the data which you're getting from the client are not negative values? In that case of course you can check the things in servlet. But the ideal case is you can add a filter just before your servlet. So there's something called servlet filter. And you can have this filter by checking the values. If it is a value is negative, then you can respond back to the client by saying invalid request. The servlet has no idea what happened, because what who has done the work is servlet filter and not just one filter. You can have multiple filters there. So one filter can call another filter. So maybe in the first filter you are checking if the number is negative. The second filter maybe you want to check the client location from where the client is accessing this data. Or maybe in the third filter you want to check something else so you can have multiple filters in between. And to connect all these filters we call them as filter chain. So what happens is when you have three filters, it's not like all the filters will execute at the same time. Basically it will go one by one. So first filter done. It will send the request to the next filter. Next filter will send request to the third filter. And once all the filters are done, then the request goes to the actual servlet. Now the same concept. We have it here. So when you implement spring security it will it will have a lot of filters already. So the moment you send a request the request goes to the first filter. Then second filter the third filter. And you have all this filter and they are in a particular order. And if you want to know which filter you can see in this it says default uh default security filter chain. So that's a filter chain. And we got this filter disable encoder URL filter. We got one more filter here which is web async manager integration filter. We got a contextual filter and list goes on there. Huge. So we got cross cause we got see CSRF and we'll talk about what is cause what is CSRF in the upcoming videos we also got authentication filter for logout. We also got authentication filter for login for user password generated filter and list goes on. So all these filters are by default arranged and they are in a particular order. And they will they will execute in a particular order. Can we change this order. Yes we can. But normally we do that. No but yeah we have the option. You can change this order of the filter. But we have all these filters here. And let's try to understand the filters one by one. Not all, but we'll focus on some of them. But then we got the idea right. So at least we are getting a login form. And when you give the right credentials you will get the access for your application. And also it's not like every time you want to access a resource, you have to log in. Once again, it creates a session as well. So you can use that session and you can access the entire application. So that's it from this video.

**Session ID**

Instructor: Okay, so till this point, we were able to secure our application with the help of Spring security and then we were getting this default password, right? So if you scroll up this time I'm, again, I'm running this, I'm getting a default password or a password, which which you get after every running. So I can simply copy this password and I can go back to my browser, hit the URL, and here basically I have to enter the user and the password, enter. I can access the page. Of course we don't have a page for the home, so I will simply go to the hello and it works, right? And of course you can have multiple URLs and you just have to log in once. Okay. Now let me show you something how exactly things are working out. So what I will do is I will just go back to my application. And here, let's go back to the controller. Let's say if I create one more thing here, which is let's say one more method and maybe I want to give the details about a particular application or a particular company. And I'm going to return let's say, so if you go to my website, I can simply say Telusko, and then I want this to be mapped with get mapping. And it should be with about, okay? So every time you hit hello or about, you can simply enter this. I mean you will get this text, which is Hello World and Telusko. Did we got a new password? No, let's go back. So you can see I'm hitting for hello. And now I will hit for about, and you can see we got Telusko. Now when you log in once, basically you can access any other resource because there's a session created for you. Now what happens is the moment you hit this particular URL, it'll check, do we have a session already available? If the session is there, then you don't have to log in every time. I mean just imagine every time you go to a different link, you have to provide username, password, not a good experience for the user, right? So if a user logged in once, you can simply go to any other page. And of course when you log out, you don't want to go to any page. I mean you don't want your user to go to any page. So let's say if a user try to get again to a page, then you have to give a login form. Now this is happening because of a session. So what I will do is I will open the inspect element. And if you can see in the network tab the request which I'm sending, I will just hit a refresh here and you can see I I requested for about now. When I click on that, these are all the details of the headers. And one thing is interesting here is a session id. So if you scroll down, you will find a cookie basically in which you have a session ID. And this is a session ID which I'm using here. Okay? Now because I'm logged in, this is session ID. Of course if I delete this cookie, then you cannot access the page. You have to re-log in, okay? But how do you know that there's a session created or how do you print it? So of course we can get hold on this and if I want, I can delete this cookie as well. You know what, we do this thing. So when you have a browser, most of the websites, let's say Gmail or another website, basically once you log in, they remember you. And every time you go there, they will simply show the page. But let's say if you clear your browser, if you delete your cookies, then you have to re-log in. That's the same thing. When you delete the cookie, you will lose your session ID. Okay, but then how do I get a hold on this? So we can do that in Java. So what you can do is in this bracket, and we have talked about this before, Spring framework behind the scene works with Servlet, right? So I mean the Spring Web which you're using, there's also Spring Reactive, which works a different way. But here we are using Spring Web, which is normal. So we'll be using HttpServletRequest and we can say request. Now why we are using it is because it has a method called session. So what I can do is I can also print this here. So return Hello World and printing request dot, I want to get this session ID. So I will say getSession dot getId. So what it'll do is it'll give you the session ID and with the text now you are doing the session ID as well. Again, not a good idea. Don't do that in production. This is only for learning purpose, which we're doing. And let me do that, the same thing for the about. And of course this board should print this same session ID. Okay, done the changes and now let me, looks like there's some problem. Oh, we have to accept it here as well. HttpServletRequest and request. Okay, so once we have done the changes, let's go back to our browser. And now if you say refresh, you can see okay, still not loaded completely. Server's getting restarted maybe. Yeah, so you can see server got restarted because of the dev tool. And now with the Telusko, which are the text, you are also printing this session ID. And remember this number last four numbers enough, three, two, double four. And let me hit hello, enter. And you can see we got this same session ID. But let's say if you do a logout now, so when I say logout, it says are you sure? Yes I am. And you can see again we got a login form. This time, let's log in. And what was the password? So let me just say password enter. Okay, I have to get the password. Now maybe I have to copy once again, copy and paste and you can see sign in. Okay, you are signed in, but we have to go to hello page. So I will say hello. And you can see this time we have a different session. So every time you log in, you get a different session. And that's how you are basically able to navigate to the entire website with the help of just one login. And if I say about, just remember the last three, last four, which is six, A, six, nine enter. And you can see we have the same ID. So that's how we maintain the session. But then we have one little problem here. The is good, but then the problem we have is every time I restart the application, I have to copy the password from here, right. Not a good idea. So I want to have my username and my password, not a normal user. How do I do that? So let's try that on in the next video. How do we configure our own username and password?

**Setting Username and Password**

Now let's have our own username. Password? See, the problem is, every time you run this application, you will get a new password. So I've run this and you can see we have a password now a new password. So what if you can have your own username password. And how do we configure that. So it's actually very easy. What you can do is you can go to your application dot properties. And this is where you can specify the property. So the property for username is spring security dot user dot name. By default it is user but we don't want it to be user. Let's say I want it to be telescope and I have to set the password as well. So I have to say password. So it is your string dot security dot user dot password. And you can set any password. The most difficult one is 1234 of course not recommended. But just to experiment with the application let's have a password which is 1234. There are a lot of drawbacks with this, but we'll talk about drawbacks in some time. What I will do is I will just save this and save this works. And every time you make a change in the properties, it's a good idea to restart your application and go back to your browser. And this time I will simply. First of all, I'm not sure if this is logged in. I have restarted the application, so let's log out. The session is already there so I will say log out. Yes, done. I don't need to use inspect element now. And here I will just enter okay. What's the username. Which of which we were using. So username for me is the Cisco and password is 1234. And when I click on sign in okay. So we have to basically access the right page. But it was logged in enter. And you can see we got Hello World. And I can also access the about now. And doesn't matter how many times I shut the application now it will ask me for the past reason and password. And the username is the Cisco and the password is 1234. It is so easy right now. What are the drawbacks of this? First of all, you are hardcoding the username password. Not a good idea having the password like a plain text. Again, not a good idea. That's one. Next, for the entire application you'll be having only one username password. Imagine when you build the application for your users or for your client. The client is sharing the username password to everyone, the same one. Not a good idea, right? So we want to have a different username password for the users. And maybe somewhere we have to store that in database. That's something we will be doing in future. But at this point this is the conference in which we have done. Don't do that in production. It's only for the learning purpose. So yes, you can set the username. You can set the password like this in the property files. And now till this point you are basically using we were basically doing the login with the help of login form. Right. But what if you are building a rest API and then you don't want to go for a login form? Uh, basically I want to send this username password from a postman or from from a react application. How will you do that.

**Basic Auth Using Postman**

Now, let's say we want to access this from a Rest client or from a react application. Now basically we have we can use a basic authentication instead of using a form authentication. So basically when we access when we were accessing this in a browser we were getting a form. But this time let's use it. Uh basic authentication. So what I will do is I will hit the URL. So basically we have localhost colon 8080. Uh hello. And then I'm sending a Get request. The moment you click on send you will get this error. Of course, this is not for not for when you you get for not for when you don't have a resource available. You got the error which is for zero one. So basically the resource is there or maybe resource is not there. Does matter. Ultimately you got the error for the you are unauthorized. So basically the authentication is missing. That's why no one should be able to access your resource without the proper authentication. And to achieve that. So if you are using postman or any other client there is an option here called authorization. I will just go back there and you can select different options here. So you can select JWT. We'll see that later. But this time we are going to use a basic authentication. So we'll click on this base basic auth. And then you can set your username and password here. So maybe I've done this before. And that's why we got default values. But then you have to enter the username and you have to enter the password. So the username is Talisker and the password is 1234. So now once you set these values I can click on send. And you can see we got the response. And look at the session ID which is different of course. And the response you get is 200. The same thing you can do for about click on send and you can see it's also working. So basically we have the same session ID because we already logged in. But now once you log in with the help of username password using basic authentication you can access the resource. Okay, so you have a choice. You can use a form login, or you can have basic authentication using your Rest client or from the application. But there are a lot of issues. Again here. Whatever password you are sending is not encoded okay. So if anyone can uh anyone can decode it. It's very easy to decode. So basically we have to also understand how do we secure this. How do we make sure that we don't send the actual password through the internet. And so that's one that's one thing we are going to do and many more.


----------------------------------------------------------------------------------------------------------------------------------------

**What is CSRF**

So basically till this point we were able to provide the security with the help of spring security. So whenever you try to access any resource which is secure, basically we'll get a login form and only when you're logged in you can access all the resources. And to achieve that we have used form based authentication I can simply use a telescope here. And password is 1234. If I say enter I'm logged in. And then we have also seen that when you log in basically you I mean what we are doing here is we are printing the text, what we wanted to print, and also we are getting a session ID that means in the browser. I do have this session ID here, but there's one little problem okay. What's the problem now see the thing is, when you're logged in of course in your cookies, you will be having the session ID so that after some time also when you go to this website, you don't have to log in once again. Basically the moment you send request it will check. We already have a session ID, it will give me the login and know what is right. And most of us do that right. We don't. We try to save the session or we say, okay, remember the session because I don't want to log in every time I go there. And I don't remember whenever the last time I logged into my Gmail account, Gmail account is already logged in in this machine. And that's what we do, right? But there's one problem here. The problem is what if I have a session right now Gmail is already logged in, and now I go to some other website which is malicious. And this website says it will search for the cookie in my browser. It will pick up the session ID for this particular site, which is my secure site, and then that particular malicious website is trying to access my secure website, let's say a banking application, and then provide the same ID, the session ID, which is taken from my browser. So this is called CSRF which is cross-site request forgery. So basically using the session ID they can access the data or the page. Now that's tricky right. So we want to secure that as well. So by default spring security will take care of it. So you don't have to manually configure it. And to demonstrate that we'll take an example. Okay. There are multiple ways of handling this. One of the way is what if with every request what you get in return is a token? Okay. So that next time when you send the request you will you have to submit that token as well. Now when you talk about HTTP, we have different methods right now out of all these methods like get, post, put, delete and many more, the get is the safest method because you don't change the data on the server. But what about the post and delete? Now of course, every time you send this you are changing something from the server. So by default spring Security will implement the CSRF for your put, delete and update and others but not on get. So what we'll do is let's create a controller for maybe, let's say for student. And let's try to see how this CSRF works there.

**Error Without CSRF Token**

So what I'm going to do is let me create another controller, and this time we will do it for the students, let's say, because I want to create some resources, I want to delete some resources. So let's not do delete, let's say get and post and let's see how CSF, CSF work there. So in this particular package of course we should create a different package. But just to make it simple I will put everything in one package. So we got a controller. So student controller. And of course to represent a student I need a class. So I will say student. And then basically I want to have a few variables here. So I will say private. Let's say I have int id and then private string name and private string technology. So for the student of course we will be do master one technology. Right okay I don't want to create a constructors to string and getters here or getters. So I will use Lombok. Unfortunately I don't have Lombok in this particular dependency. So let me add for Lombok and of course we know how to get the dependencies now. So I do have the Lombok dependency saved somewhere. So I will just copy it. Now the moment you do that, you have to reload your maven for the changes and it should be done quickly. Let's go back to the student and the annotation I'm going to use is data. And I want all argument constructor and also no argument constructor. And that's done. It will take care of the remaining things. Let me go back to student controller and let's create what. So let me just say this is a Rest controller. And of course I should be creating multiple layers. But again I just want to keep things very simple. Less number of classes. It will not confuse you. But again, this is not a production ready code because we have to create multiple multiple layers. The service layers repository layer and maybe data is coming from database. Let's not do that. Everything in now. Let's keep it simple. Let me say I want to create a list of students, some static data. And okay we have to import the package first. And then I will say students equal to new ArrayList. And in this I want I do want to have some of the uh, students by default list off. And let's create some students. So as a new student, uh, which will have, let's say one as an ID name is Naveen and let's create only two. So I will say this is Java and then new student this will be two. And then I will say let's say Kiran And here I will say technology is let's say blockchain. Okay. So basically we got two students and now let's fetch all the students. And the way you can do that is by having a method. So let's say for a particular URL slash students I want to return some data. And I want to return basically a list of students, let's say get students. And then here basically I will say get mapping for the URL. What's a what's a URL? I want this to be for students. Okay. And then let's return the students. That's it. Nothing fancy. We got a list of students and we are going to return that after making these changes. Because I have changed the maven as well. Let me start once. I will enable the annotation processing which should be done quickly. Let me go back to my browser. Let's initially let's do that with the browser and let's then move to postman. And I will say students enter okay. Of course. Right. You have to pass username. Password. The username is telescope. The password is 1234. Enter and voila you can see we got the details. We got two students here I'm using an extension. That's why you can see it's a beautiful format okay. Now here let me go back to my postman and let's hit the same query. So I will say students, that's the data. I want to fetch a get request in the authorization. Of course we have to pass the values the username password. And when I click on send you can see we got the response. So it's working in the browser. It's working on postman as well. And now let's try to do something for the adding. So let's say I want to add a new student. In that case of course I have to create a method which is public. I don't want to return anything. So void add student. And here basically we have to accept the student. Right. And the way you can do that is by saying request body I want to accept student because that's that's what I'm going to send from the uh from the postman. And the mapping which I'm going to do is post mapping not get. And again I will do it for students only. So we'll say students okay. And once you get this data I want to add this data in the student services students dot add I want to add a student. So whatever new student I'm receiving I'm just adding that to this particular list here. Nothing fancy okay simple stuff. But the question is will it work. Because what we have here is a post mapping. Now we have not used this RF token anywhere, but still the Get was working. The question is the post will this work? Let's try out. So what I will do is I will just we don't have to relaunch because we just added some method they have to resolve there. Let me go back to my postman and this time I have to hit a post request. So I just need some JSON data to hit the post request post and in the headers. No, not in the headers in the body. Basically I have to enter a new record. So let's say this is three. This is Hirsch. And let's say Hirsch loves to work with JavaScript. And now click on send. And you can see we got an error. Now this is not the error for username password because we are sending that. What's the issue. The issue is with the CSV. Basically by default this will be blocked because we are not sending the same sort of token. And this is not just for this particular request. Remember when we were trying to log in, let's, let's go to log in and see what happens. So let me open this and say maybe let's let's do log out when you so log out and we are in the log out page now. So if I go back to View source you can see every request will have a CSRF token. This is missing and the value is also missing I don't have this value. So basically if I want my post request to work, I just have to send a set of token with the value this and that's it. It will work. But the question is how will I get this value. So what we can do is we can get the CSRF token from the application. So let's create a method which will return us a set of token. And we can simply copy the token and hit the query. If we can do that our job will be done.

**Sending CSRF Token**

So how do we get this CSS out of token? And even if you get that where you will put it. So basically if you go back to your postman and when you send the post request in the headers, uh, you just have to go down, let me just hide the other headers. And here basically we have to send x hyphen css, rf token. Basically this is a token which you have to send. The only thing is I don't have a value. If I can get the value, I can simply copy it and paste it here. My job will be done, but I don't have a token. So how do we generate this token? So what we can do is in fact we don't have to generate, we just have to get it. So I can create a method here to get the token and the way you can do that. In fact, with the student itself, you can send the token if you want. But I will not disturb this. What I can do is I can create another method which will return me the c s r f token. This is coming from the spring security web dot csv. I will just enter this and then we can have any any method name. I will say get c s rf token. So basically we have to return this CSF token right. And let's do the mapping for this as well. So I will say get mapping. And the request I will ask for is you can say token even that works. Or maybe it will have a proper name to it, CSRF token and then let's return. But who has this as a token. So basically whenever you send a request your SDP servlet request object, remember we have used that before this particular object, not just have your session ID for example, if you go back to the controller, remember we have used request dot get session. Uh, if you try to say like this, if you say request dot, you can see it will have a method for get attribute. And inside this attribute you can pass the token name. Okay. Let's do that in our particular class or the the method which we have created here. So we'll do the same thing I will say return request okay. For that we have to get hold on HTTP server request object. Now I can say request dot get attribute. And the attribute name is what? Now this is something we have to remember when we went to the view source page of logout. We have seen it is underscore c s r f. And that's it. We have to mention this token I mean this attribute and it will get it. The only problem is this get attribute returns something else and you want something else. So we can basically do the casting and that will work. So we are basically converting that object to a CSRF token object. And by doing this we will get token. Let's see. Do we get this. So let's go. Go back to the postman and first we'll send the get request. I do want this post request but I will send the get request for c s rf token. I will click on send and you can see we got the token. Okay. You can see the header is header name. It says I have token. This is the same token we have to use when we send a Post request. And this is the token. So I will just copy this. Make sure you have to you have to copy from double quotes double quotes. And now let's use that in the post request which we have send this one. We already have a data here. But in the headers we have to pass that x hyphen CSRF token and pass the value. That's it. If you paste it properly and when you click on send this time we have not got the error of 401. We got 200, which is success. But is it really. Let's try. Let's try to fetch all the students and say send. And you can see we got three as well. So this is working. And that's how basically every time you want to send a request not for Get, but for the other request, you have to send the token as well. So every time you send a request it will give you a new token. You have to use it and it will work. That's one way of solving this. The second way of solving this is what if you will not even allow for some other website to use your session ID? I mean, problem solved, right? The entire problem started because some other malicious website is using your session ID to access a particular resource. What if you don't allow that? What if you say, hey, you can only use it from the same website? Problem solved. Right? How do we do that? Let's see that in the upcoming videos. But at this point, now we know how to use CSRF token. What is CSRF? And that's it from this video.

**Same Site Strict**

So now we know the importance of CSRF token. So basically what we have done is every time you send a request which is not a Get request, we have to send a CSRF token with the request, otherwise it will not work. You will get the error which is 401. And the way you can send a CSRF token is basically in the headers. Basically you have to add a key which is your x CSRF token, and then you have to pass a value. And the way we got this token is because of this particular method here. So if you can see we are requesting for a token and we are getting a token. Now why we are trying to secure this is because if you are trying to send a request from a malicious website or some third party place, uh, basically the third party will not be having the token, right? So we have seen the example before, and this basically solves the problem. So we have two things here. The first one is what if you don't even allow for anyone outside the same website to access your server? So basically what I'm trying to say is what if you don't allow someone else to access it? So what I'm trying to say is, what if you simply disable the cross site access? What if only one single site access is provided? And the way you can do that is by setting the property here as same site. So if you type same site, you can see we have multiple options by default is lacks let's say strict. Now this will make sure that you can only access from the same website. Now this is one solution we have from CSV. So this is a good idea to put it strict and no one can access it now from the outside world. Now let's talk about the second part. The second part is when we talk about rest API. This can be two types of rest API. First is stateless and second is stateful. Now in the stateful basically you maintain this session. And that's why every time you log in for the subsequent request, it uses the same session ID, right. And we have seen this. If you open your browser when you request for hello, you can see it will give you a login page. And here you have to enter your username and you have to enter your password. And then you get this. And every time you send a request let's say I'm sending a request for about now. And if I say enter you have the same session ID even if you use for students. And if you say enter, uh, of course this is also happening with the same session ID let me just refresh. Refresh. Every request will have the same session ID what if you make it stateless and most of the time when we use a Rest application, basically they will be stateless. Now in that case, do we? We don't even have to use a CSRF token because in the stateless you have to send the request with the username password every time. So we don't have to maintain the session. Right. So we don't even need CSRF. So what we have to do is in this particular code let's make it stateless. And then we don't even need to use CSRF token then. And basically we have to disable it. How do we do that.

**Security Configuration**

Now let's change the configuration and let's disable the CSR of. Token. Now question arises how will you disable it? Because by default, whatever we have done, we are doing it with the default configuration of spring. The only thing we have which we have changed is the username and password. Right? Apart from that, everything remains same. So spring is giving you the configuration by default. Now we don't want to use default configuration. We want to have our own configuration. How we are going to do that. And we know in spring, whenever you say you want to decide your you want to define your own configuration. We have to do that with a class for configuration. So what I will do here is let me create a class and we'll say this is security config. That's a class name. And I will move this to a different package let's say config package. Logically everything should be a different package. Your controllers, your models. But just to keep it simple, I'm putting that in the same package. But config I want to be to be separate. Okay, so we got a config package here. And now how do we configure this? First of all now since you are saying this is a configuration. So let's annotate it with configuration. Now in the recent version of spring we have to use Enable Web security. This is an option which we have used if you want to enable the web security okay. So what next. So basically in spring six there are certain things which are change in spring security in terms of the way it is implemented. Now when you want to change something, basically we have to return the object of security filter chain. So basically if you want to change configuration we have to return object of security filter chain. That means we have to create a bean which will return security filter chain object. Okay. And if you can do that, basically you are changing the config. Now let's have a method name. Of course you can have any method name. I will go for security filter chain and bracket open close. And I want this to be bean okay. So by default it will create a spring will create this object for you if you are not defining it. So entire spring security behind the scene works with this spring security filter chain for the filters in between. But now we are changing it. Now we have to specify our own configuration. And how do we do that? So by default even this uses something called HTTP security to do that. So that means we have to pass an object of HTTP security and we'll say HTTP. That's the object. And now we have to return this object. Right. And the way you can do that is very simple. Basically we have to say HTTP dot build. This will return you the object of security filter chain. Also build and let's return this okay. It might throw an exception. That's what it is saying I guess. Yeah. So we have to add throws exception okay. Nothing fancy. We have just created a simple configuration class. And since you want to change the default configuration we have to return the object of security filter chain. And what we have done is we have got the hold on the object of HTTP security, and we are simply saying build. Now what it will do is okay, let's try, let's try. I will show you what it does. First of all, let me restart the application. I want to make sure that it is actually reloaded before we see the output. And after doing this, let me go back to my browser and I will open the incognito mode and let me hit the URL. So the URL we are going to hit is localhost colon 8080 slash. Hello and enter. That's weird. I have opened a incognito mode. If you can see this is not a I mean it's not like there's a session already built and it is not even asking for the login form. So basically we broke this spring security. So your thing is since we have changed the security here by default, if you don't do this, spring will take care of it. Spring will say okay, there are a lot of default configuration available. So every time a user try to access a particular resource, we'll check for certain filters. If the user is logged in is enabled. I mean all these different settings. But what we are doing now is we are saying we have got the HTTP object and we are saying, let me specify what I want, and then you have specified nothing there. And spring security says it's your wish. You're basically breaking the rules here. Okay. So that's what is happening. Because if you see the enable web security here, and if you go back to the by default HTTP security config, which is importing, and if I go back there, there are a lot of pre configure stuff happening here. If you can see uh there is a log out page available. There's a log in available. There's a CSR enable. And there's so many default stuff which is happening. And what we are saying now is hey let me handle the things and we are not handling it. So how do we how do we specify the code here.


------------------------------------------------------------------------------------------------------------------------
**Disabling the CSRF Token**

Now configuration looks a bit difficult at the start, but then we will get used to it. And of course we will be doing this only once in our project. So not a big thing right. And most of the project will have almost the same settings. So let's do that. Now to do this we have two approaches. One is the lambda way and second is the imperative way. I will show you the lambda code. I will not explain much and there will be still some confusion why we are using this object, why this particular method, and in the next approach where we are going to do this imperatively, where you have to define all the objects and then passing it, it will make much more sense. Now if you look at the code, lambda will be shorter, imperative will be huge number of lines. And ultimately in your project you're going to use Lambda way. But then if you want to understand this, we have to also understand the imperative way. So first we'll do the lambda code. I will not explain much. And even if you have some confusion, just wait. Wait for the imperative way. Then it will make much more sense. So when I say I have to do this, I have to configure this. What are the configuration you have to do? First of all, before we build the HTTP object, we have to make some changes. The first one is HTTP dot and using this dot. Of course there are multiple methods where you can set the things, and you can see when you say Dot, we got all this options here. And the earlier one we used to directly use CSRF and now you can see it is deprecated. The new way of doing it is with the help of CSRF, but it will ask you for an object. So let's do this instead of disable first. Now the first thing we are doing here is we are disabling the CSRF. So what we will do is we'll say http dot CSRF in this bracket we have to pass a customized object. I'll say, or maybe any object doesn't matter at this point. I'm just saying customize. I will see why I'm saying customizer. But I got this object and I will simply say customizer dot disable. So by doing this we are disabling the CSRF. It's that simple. This the code has been changed. Initially it was CSRF dot disable, but now we have to say we have to take the object of customizer and then say disable. That's the first one. Next I want to okay, let's see what happens when you just do this. Let me just restart the application and go back to the browser say refresh okay. Still service not started yet. Let's refresh once again. And you can see there's still no, username password. You know why? It's because we have to enable it. So to enable the username password we have to say authorize HTTP requests. Initially it was an authorized request but now we have to use authorization request. And here we have to say let's say we use a variable name as authorize. Or maybe I will say request for all the request I will say request dot any request dot authenticated. So by default we have to authenticate it. Again I'm not explaining what I'm doing here. What is this request object I will do that in the next video where we talk about the imperative style. But here we are just saying what are the settings we have to do. So what we are doing is first we are disabling the CSRF. Second, we are making sure that we are enabling all the requests. I mean, we are enabling the security for the request. So for every request I'm saying authenticated. And now I will go back to my browser. Now since this session is already created, I will open a new incognito mode. Or maybe I could have used a new window there localhost colon 8080 slash. Hello. Enter. Okay, so if you can see when I did that something happened. It was it tried to download something. Okay. So I'm trying to do that from the postman. I think there's some session saved in the cognitive mode, in Chrome. But you can see when I send a request it says forbidden. So even if I provide the authorization, it's not working. So if I say no auth send, it's forbidden. So basically we have to provide a form so the form is missing. So what I will do is I will say HDP dot form login. And I will say I will go for a default option. So with defaults I don't want to change anything in the form login. And then I also want to use the HTTP basic for the security. I will say customizer dot with defaults. Now by doing this I think it should give you the form login. Now let's try relaunching the application. I will open my browser and say localhost slash. Hello. Okay, so now you can see we got a form login. Now basically by doing this we got a form login. And now we even if you try to use your postman it will work. Right. So if you say postman we got 401 unauthorized. But if I set the authorization to basic auth and send, you can see we got 200. So basically what we have done is we are using a login. And if I say the let's go 1234 four, sign in and every time I refresh you can see we have the same session ID. What I want to also achieve is we want to make sure that you get a new session. So basically I wanted to make it stateless. And the way you make it stateless is by saying HTTP dot. And this is something called session management. By default it is going for stateful. And if I want to make it stateless I just have to take the object off session. And on that session object I will say session creation policy. And we can get that from session creation policy. Dot you can see we have multiple options. We have stateless. We have if required we have always. We have never. So I will go for stateless because I don't want it to maintain sessions. And that's it. This is how you make it stateless. And now once I do that, if I go back to my browser every time I refresh, okay, it's always loading asking for username password. So I will say to go 1234 sign in okay. It's not going for the username password because it creates a new session. I don't want to use it from there. Let's use it from here. Okay. So since we are making it stateless we have to send a rest API for all the requests, right. So you can see when I say send. Now we got 200 here which also means I have to disable the form login. We don't need form login when you have stateless. That's one thing we have learned now. Great. So if I click on send you can see we'll get 200 every time the server needs to load. And you can see we got the output. And the beauty is every time you send a request you will get a new session. Can you see that session ID here. It's changing. So every time you say send you will get a new session. So that's how basically we can provide the settings here. But then we have to understand this. And also we have disabled the CSS. If you want to see how what I will do is I will send a request for students. Let me say get students first say send. And you can see we have only two. I will try to create new one. And we do have it here. We do have a body as well. And then if I go back to the authorization, I have basic auth in the headers. I will not be sending CSRF token now. And when you click on send you can see it worked. We got 200. Now we don't have to pass a CSRF token because every session is new. In stateless we don't have to use CSRF token and that's it. Now in the next video let's try to understand what is happening here. Why? What is this code or can we just simplify this mode?

**Without Lambda**

So now let's convert this code into a imperative style. So I mean normal style. So what I'm going to do is let's comment this entire section. In fact till here okay. And now let's work one by one. So first thing we have to address is HTP dot CSRF. Now if you can see if we talk about CSRF it takes a parameter of customizer and of type CSRF. Configure of type HTP HTTP security. So basically we have some types there. So customizer takes a type of custom CSF configure which takes a type of security. So what are we going to do is we create an object of that. And let's pass it here. So you have to create object of customizer of type cs RF configure of type HTP security. And then I will say this is. customized CSS RF equal to new. And we'll get the object for the same thing. And you can see we got the object. But the thing is customize itself is a interface right. So if you want to get the object of it we have to use anonymous inner class. That's what I'm doing here. And in this interface we only have one method. If you can see the method name is customize. So what I can do is I can just define that method customize. And okay that's the object we have created. So the object name is or the reference name is cust CSRF. And we have to pass that cust CSRF here okay. So CSRF says you can configure me by passing the object of this. And this. The object type is customizer with the type CSRF. Configure HTTP security. Now if you're thinking do we have to remember this. Not exactly. Anyway. When you are actually going to build we will be using the lambda expression, not this type of code. I'm just showing you this so that you can understand what is happening. So in this particular object creation we are using a method called customize because that's the only method you have which takes a parameter of CSF configure which you are passing here of of type HTTP. And in this you can do the configuration. So what I will do is instead of saying this big name I will say configure. And then using that object of configure, I can simply say disable. Okay. So whatever you want to do with this configure you can do that. You can set different different properties or settings. I'm just saying disable. And the same thing I'm passing here. So this one line of code is actually doing all this. Again, if you are good with Lambda you don't even have to watch this video. You can skip it. But I'm just trying to make you understand how we got this. Because when I saw this for the first time, I was like, hey, what's happening behind the scene? And this is what is happening. Okay, next, let's talk about the authorization request, the same thing. We can do that. So we have to say http dot authorize HTTP request. And even this needs object of customizer. So if you go there you can see this particular method needs object of customizer. But of type authorize HTTP request configure of type HTTP security. big names like and. That's why we prefer to go with Lambda there. So for this we have to create the object I will say customizer of type authorize HTTP request, configure of type HTTP security. And then again you have to say dot. The actual object we have to create is authorized manager request manager registry. And for this we will create object of cost should be equal to new. The same thing and you can see it's very lengthy name. Right. And no one want to remember this. So you can see it's such a big name. So we have to create object of customizer with this type of authorized manager request manager history. And once you have this object because that's the object we have to pass here which is cost SDP. And here in this bracket or in this definition I will say was the name registry. So we'll say registry dot for every request dot authenticated. So basically I'm saying get authenticated. And that's how we can basically pass this. Yeah. So this is basically your imperative style of writing this. Not a good idea right. But then now you know which classes are involved behind the scene Okay. And preferably we'll be using the lambda. So this is only for showing you how things looks like. But this is not the actual way of writing code here. I will still prefer the lambda. Let me just uncomment this the for the session. Also we have did the same thing. You can explore session management. We have to create object of. Customize the session management, configure which of type HTTP security and this will work. There's one more way of doing this since SDP follows a build up pattern. Instead of writing all this multiple times, what you can do is you can say HTTP dot csv and then you can say dot with the same thing. So this is a builder pattern. So you don't have to mention semicolon there at the end. So we are configure http for CCF first then authorize request and then dot http and then dot session management. So you can see we are doing this in a line now. And that's how we can do. In fact, if you want you can see at the end dot build and return that object itself instead of doing all these things. And that's why most of the time you will see this type of configuration or some way. You can also see this in a new line if you want, just to make things visible. So yeah, that's how we can configure the CSRF disable and other things here. There are many configuration which we can do. Maybe having multiple username password, not just one. But how do we do that.

**Getting Ready for User Database**

So far, we have been able to secure the request. And we do it with the help of the username and password. In fact, one thing we haven't seen is what happens if I open the browser now. So I'm going to open incognito mode, because someone might already be logged in, and I'm going to go to localhost colon 8080 slash. Hello. And if you press enter, you can see that we get a pop-up window here. Not a form. The reason is that if you go back to your code and to what we've done, in the configuration, we said that we wanted to use HTTP basic authentication, and not a login form. That's why we don't get a login form. We get a prompt. And of course, here, it will work. So if you enter telescope and 1234 and hit sign in, it will work properly. And of course, every time you refresh your data, you get a new session ID. And if you want to log in again, of course you need to close it, because logout won't work right now since we haven’t added the logout filter. So if I say "logout," it doesn't work. In fact, we don’t use logout because we are doing stateless authentication. And every time you send a request, you have to send the credentials. If you're using a REST API, even if you open a new incognito window, the session will be maintained and you can close it from here. That should work. Coming back to the code, that's the only thing I wanted to show you. Now, what I want to do is that the username and password are fixed, right? Of course, before making these settings, we used to get a username like "user" and the password we would get from the console. But now I have specified that the username I want to use is "telescope." The password I want to use is "1234." But what if you want multiple users? Because in the end, in this particular application, there’s only going to be one user. I don’t want that. I want to have multiple users. In that case, we need to make adjustments. In fact, it’s not just about having multiple users—we want these users to come from the database, right? The values are hardcoded here. That’s not how it should work; the idea is that every time someone registers in the application, we need to store their data in the database, and they should be able to log in from there. These are the credentials. So in this series, we’re going to focus on how to have multiple usernames and passwords. We’ll start with in-memory. Then we’ll slowly evolve toward integrating that data into a database. And how can we secure it? Because we don’t want to store data or the password in plain text on the server. So we need to encode it. We’re going to focus on all of that in the upcoming videos.

**Working with Multiple Users**

So now let's write a code so that we can have multiple users. And of course we want the users coming from database. But then we'll go step by step so that it will make sense. The first thing we will do is let's hardcode the username password values not from database, but let's hardcode them here in the code. And I don't want to use this username password. Now the way you can achieve that if you go back to your security configuration. And if you don't mention anything here, by default this spring security uses something called a User Details service. Now it uses this class to basically check for your application properties and see do you have username password there? If yes, it will use it, but I don't want to use that. I want to define my own user detail service. So what we will do is let's create a bean which will return a user details service object. And I can say this is user detail service method. Okay. So basically I want to return the object of user detail service. And I want this to be bean. Now what will happen is your spring security will look at this particular object to get the data for the user. So whatever data you're going to return in this will be your actual data where a spring security will check. Okay make sense. But how do you return the data? How do I specify the users? And basically how can I return this user detail service? Now if you go back to user detail service, it's a interface, right. And it has a method called load user by the username. Okay. So this is a method which is getting used behind the scenes. Our concern is this particular interface. It's an interface. First of all it has a method which returns the object of user detail service. So for us the two important thing is this interface name. And it returns return type which is user details. If I go back here and if I try to understand how do I create an object for this? Of course we don't want to get our own own class. Now there is a class which we can use. So I can simply say return. And the name of the input class is. If you can see we have something called in Memory User Details Manager. So we are going to use this because this particular object and if you see this implements User Details manager which extends user detail service. So indirectly this particular class which is in memory User Details manager implements the user detail service. So our job is done because if you can return the object of this indirectly, you're getting the object of user detail service. Okay. But then we don't want to return the empty object right. We have to specify some values. Let's try. And I want to really check if this works. If I if I do this it should not even accept the username and password which is specified in the application properties. Let's try it out. So I hope this will okay I will just manually restart. Sometimes we don't trust the hot reload, especially when you are experimenting. Okay. Reload. Done. Let me go back to the browser and again I will go for the incognito mode. And here let's specify localhost 8080. It will give you a prompt. And now I will specify the list And 1234 enter is not working. So basically the username password which you have mentioned in the application properties is not getting read. Okay. So now let's specify the values here. Now how do I specify the values. See in this constructor of in-memory user details manager, if you click here you can see it has multiple constructors. One of the constructor is this a collection of users. If you don't want to pass a collection, you can also pass a variable length arguments, which is varargs and you can pass multiple users. So I want to use this particular constructor. And I can pass any number of users I want. And what object, what type of object you want to return the user details object. So that means here, even if you want to create one particular user, you have to give an object of user details. Here I will say user is equal to I should be importing this package. I think it's already done. And now how do I create the object of this. If you go back to user details oh this is also interface. I mean it's all coded for the interface. No problem. I will go back here and there's a class called user okay. So the way we have user details we also have user and this particular class. It has multiple methods. It returns an object of user builder if you can see and user builder. So it has a method called build which returns user details. And of course you don't have to remember every flow here. Just imagine the user has a method called user builder. I mean a builder dot build. So basically user dot builder build will give you the object of user details. But then this is empty right? We don't want to go with empty one. I want to specify some values to it. So the first thing we have to mention is the password encoder. As I mentioned before you don't want to store your password in a plain text. You want to store that in an encoded format. So this to start with let's not do any encoding. I will go for a default password encoder, this one. So what I'm doing is I'm saying hey I'm going for a default password encoder. And now I want to specify my username. So you can say dot username. And you can mention the username. So let's say I want to go for username as Naveen. And then you can say dot. You can also set the password I want to set the password as n at the rate added 1 to 3. That's the password. And then if you want you can also specify the roles. And you can specify multiple roles here. So if Naveen I want it to be admin as well as I want Naveen to be user, I can specify both, but at this point let's say I want to specify only one thing and that too makes sense if you have in the capital. So we'll say user and then at the end you can say build because build returns object of user details. And that's what we want right now. If you want this to look good, what you can also do is at this point you can say enter just like a builder pattern and you can say enter here. So at least it will make it much more readable compared to the earlier one. And if you try to read now, what it says is we got a user in which you have a chain of methods, we are going for default password encoder, then we are going for username password roles and build. And this particular object, the user object. I can simply pass here because that's how we can pass the object of user details to the constructor here. And you can pass multiple objects, not just one user. You can create multiple user details object and you can pass it here for multiple users. And now let's talk about this. What is this with default password encoder. Now basically this is a method which says I don't want to go for any encoder at this point. Later on we'll move to different encoders. But at this point we're not using it. But again, not recommended. And that's why it says it is deprecated. We should not be using this in the production. Or I mean you should be only using it while learning purpose. Never use it for even for experiments sometime. Yes, you want to check if everything is flowing well and you have a password in database, and if you want to verify that, that's when you can do it, but not in the normal scenario. Okay, so we got a user and I can do the same thing. Let's say I want to have one more user here which is this. And I can say this is user. Maybe I want to create a admin now with default encoder. And I will say let's say kitten. Or maybe I can have admin itself. And the password I want to go for is admin edit 123 or maybe admin 789. And the role I want to give here is admin. Okay. That's how we can create another user here. And here we can pass admin as well. So depending upon how many objects you have you can pass those objects here. Now I hope this will work. Let me relaunch again I don't trust the hot reloads. So it's launching I will go back to my browser refresh okay so we're not started yet. Server started. And now here I will say let me try to go once again. And I would say 1234 not working. Let me say Naveen and the password I will just enter a random password which is incorrect. Sign in not working again I will say Naveen and the password is n at the rate 123 sign in worked. Okay, so whatever, whatever details or whatever username password you mentioned, you can use that here. What if I want to try with admin. Let's try. So that's the new incognito mode I will say admin password is admin at the rate 8789 enter. It worked. So basically whatever username password you mention here it will work. But again this is not coming from a database. Let's see how do you make it work with the database in the upcoming videos. But at this point what we are doing is we are not going for a default implementation of user detail service. We are defining it by ourselves. And the way you can do that is by returning the object of in-memory user details manager. And we are returning this to objects. So yeah, that's it from this video.


_------------------------------------------------------------------------------------------------------------------------------------------


Below is a detailed explanation of the process described in the provided text, organized into paragraphs with side headings. Each section covers the steps and concepts discussed, ensuring all details are captured in a clear and comprehensive manner.

---

### Hardcoding Username and Password in Spring Security
To begin, the goal is to configure Spring Security to authenticate multiple users without relying on the default username and password defined in the application properties. Instead of using the default configuration, the username and password will be hardcoded directly in the code. Spring Security typically uses a `UserDetailsService` to retrieve user credentials, which by default checks the application properties for a username and password. However, to customize this behavior, a custom `UserDetailsService` will be defined. This is achieved by creating a method named `userDetailsService()`, annotated with `@Bean`, which returns a `UserDetailsService` object. By defining this bean, Spring Security will use the data returned from this method to authenticate users, overriding any credentials specified in the application properties.

### Defining a Custom UserDetailsService
The `UserDetailsService` is an interface with a key method, `loadUserByUsername`, which returns a `UserDetails` object. Instead of implementing a custom class for `UserDetailsService`, the built-in `InMemoryUserDetailsManager` class is used. This class implements `UserDetailsManager`, which extends `UserDetailsService`, making it suitable for returning a `UserDetailsService` object. The `InMemoryUserDetailsManager` allows for specifying user credentials in memory, which is ideal for hardcoding usernames and passwords. To test this setup, the application is restarted manually, as hot reloading may not reliably apply changes. Upon accessing `localhost:8080` in an incognito browser window, the default credentials from the application properties (e.g., username: `list`, password: `1234`) are no longer accepted, confirming that the custom `UserDetailsService` is in effect.

### Specifying Hardcoded Users
To populate the `InMemoryUserDetailsManager` with user data, user credentials are specified using its constructor, which accepts a collection or variable-length arguments of `UserDetails` objects. To create a `UserDetails` object, the `User` class from Spring Security is used, which implements the `UserDetails` interface. The `User` class provides a `UserBuilder` through the `User.builder()` method, allowing configuration of user properties. For example, a user named `Naveen` is created with the password `n@123` and the role `USER`. The `withDefaultPasswordEncoder()` method is used for simplicity, though it is deprecated and not recommended for production due to its lack of secure password encoding. The builder pattern is applied for readability, with each method call (e.g., `.username()`, `.password()`, `.roles()`) on a new line, culminating in `.build()` to create the `UserDetails` object. This object is then passed to the `InMemoryUserDetailsManager` constructor.

### Adding Multiple Users
Multiple users can be added by creating additional `UserDetails` objects and passing them to the `InMemoryUserDetailsManager` constructor. For instance, a second user named `admin` is created with the password `admin@789` and the role `ADMIN`. Each user is configured similarly using `User.builder()`, with the default password encoder, username, password, and role specified. The application is restarted to ensure the changes take effect, and testing in an incognito browser confirms that the hardcoded credentials work. For example, logging in with `Naveen` and `n@123` or `admin` and `admin@789` succeeds, while incorrect credentials fail. This demonstrates that the custom `UserDetailsService` successfully overrides the default configuration and authenticates users based on the hardcoded data.

### Transitioning to Database-Driven Authentication
While hardcoding credentials is useful for testing, the ultimate goal is to authenticate users using data from a database. To achieve this, the default `UserDetailsService` provided by Spring Security will be replaced with a custom authentication provider that connects to a database. This requires creating a bean that returns an `AuthenticationProvider` object, named `authProvider()`, and annotated with `@Bean`. The `AuthenticationProvider` interface defines an `authenticate` method, which processes authentication requests and returns an `Authentication` object if successful or throws an exception if authentication fails. Since the application will interact with a database, the `DaoAuthenticationProvider` class is used, as it extends `AbstractUserDetailsAuthenticationProvider` and implements `AuthenticationProvider`.

### Configuring the DaoAuthenticationProvider
The `DaoAuthenticationProvider` requires configuration to connect to the database. Specifically, it needs a `UserDetailsService` to retrieve user data and a password encoder to handle password verification. Initially, the hardcoded `UserDetailsService` (using `InMemoryUserDetailsManager`) is commented out, as it relies on static values. A new `UserDetailsService` will be implemented to fetch user data from the database. The `DaoAuthenticationProvider` is configured by setting the `UserDetailsService` using the `setUserDetailsService` method and specifying a password encoder with `setPasswordEncoder`. For simplicity, the `NoOpPasswordEncoder` is used, which does not encode passwords, though this is not recommended for production. The `UserDetailsService` is autowired into the configuration, requiring Spring to provide an implementation.

### Implementing a Custom UserDetailsService
To fetch user data from the database, a custom `UserDetailsService` is created in a new class named `MyUserDetailsService`, placed in a `service` package for organizational clarity. This class is annotated with `@Service` and implements the `UserDetailsService` interface, requiring the implementation of the `loadUserByUsername` method. This method takes a username as input, queries the database, and returns a `UserDetails` object. To interact with the database, a repository interface named `UserRepo` is defined, which will be autowired into `MyUserDetailsService`. The `loadUserByUsername` method uses `UserRepo` to query the database for a user by username. If the user is found, a `UserDetails` object is returned; otherwise, a `UsernameNotFoundException` is thrown with a message indicating the user was not found.

### Creating the UserRepo Interface
Since the application uses Spring Data JPA, the `UserRepo` is defined as an interface extending `JpaRepository`. This interface requires two parameters: the entity class (`User`) representing the database table and the type of the primary key (`Integer`). The `User` class, representing the `users` table, is created in the `model` package with fields for `id`, `username`, and `password`, annotated with `@Entity` and `@Table(name = "users")` to map to the database table. Lombok’s `@Data` annotation is used to generate getters, setters, and other boilerplate code. The `id` field is annotated with `@Id` to mark it as the primary key. In `UserRepo`, a method `findByUsername(String username)` is defined to query the database for a user by username. To ensure uniqueness, the `username` field should ideally be marked as unique in the database schema, though the current design uses `id` as the primary key.

### Handling User Data and Exceptions
In the `loadUserByUsername` method of `MyUserDetailsService`, the `UserRepo` is used to call `findByUsername(username)`. The result, a `User` object, is checked for null. If null, a `UsernameNotFoundException` is thrown, indicating the user was not found. If a user is found, the method must return a `UserDetails` object. Since `User` is a custom entity and not a `UserDetails` implementation, a new class is needed to bridge this gap. This is addressed by creating a `UserPrincipal` class that implements `UserDetails` and wraps the `User` entity, allowing the application to return the required `UserDetails` object.

### Implementing UserPrincipal for UserDetails
The `UserPrincipal` class is created in the `model` package and implements the `UserDetails` interface, which requires several methods: `getAuthorities`, `getPassword`, `getUsername`, `isAccountNonExpired`, `isAccountNonLocked`, `isCredentialsNonExpired`, and `isEnabled`. For simplicity, the account status methods (`isAccountNonExpired`, etc.) are hardcoded to return `true`, assuming all accounts are active and valid. The `getUsername` and `getPassword` methods retrieve the respective values from the `User` object, which is passed to `UserPrincipal` via a constructor. The `getAuthorities` method returns a collection of `GrantedAuthority` objects, representing the user’s roles. Since the `User` entity does not currently include a roles field, a hardcoded role (`USER`) is assigned using `Collections.singleton(new SimpleGrantedAuthority("USER"))`. In a production system, roles should be stored in the database and retrieved dynamically.

### Integrating UserPrincipal with UserDetailsService
In the `loadUserByUsername` method, instead of returning the `User` object directly, a new `UserPrincipal` is created, passing the `User` object to its constructor. This ensures the method returns a `UserDetails` object, as required by the `UserDetailsService` interface. The `UserPrincipal` constructor assigns the `User` object to a field, allowing access to its properties in the `UserDetails` methods. This integration completes the authentication flow: the `DaoAuthenticationProvider` uses the custom `UserDetailsService` to load a `UserPrincipal`, which provides the necessary user details for authentication.

### Testing the Database-Driven Authentication
After implementing all components, the application is restarted to ensure changes are applied. Testing is performed in an incognito browser by accessing `localhost:8080`. Credentials from the database are used, such as username `naveen` with password `n@789` and username `hirsch` with password `h@123`. Successful logins confirm that the application is correctly querying the database and authenticating users. Entering incorrect credentials or a non-existent username results in a failure, with the `UsernameNotFoundException` being thrown for invalid usernames, as evidenced by a 404-like error message. This validates the end-to-end functionality of the custom authentication provider, `UserDetailsService`, and `UserPrincipal`.

### Organizing the Project Structure
To maintain a clean project structure, related classes are organized into packages. Controllers (`HelloController`, `StudentController`) are moved to a `controllers` package, the `User` and `Student` entities to a `model` package, the `MyUserDetailsService` to a `service` package, and the `UserRepo` to a `dao` package. This organization improves maintainability and clarity, ensuring each component has a logical place within the project.

### Future Considerations and Best Practices
The current implementation uses `NoOpPasswordEncoder` and `withDefaultPasswordEncoder`, which are insecure and deprecated, suitable only for learning purposes. In production, a secure password encoder like `BCryptPasswordEncoder` should be used. Additionally, the `User` entity could be enhanced with a `roles` field to store user authorities in the database, eliminating hardcoded roles in `UserPrincipal`. Features like account expiration, locking, or credential expiration can be implemented by modifying the `UserPrincipal` methods to check relevant fields in the `User` entity. The next steps involve reviewing the entire project flow to solidify understanding and exploring advanced Spring Security features.

---

This comprehensive explanation covers each step and concept from the provided text, organized into clear sections with descriptive headings, ensuring all details are captured in paragraph form.

Below is a detailed explanation of the provided text, organized into paragraphs with side headings, covering the project summary, Bcrypt explanation, user registration, Bcrypt encoding, and password encoder setup for authentication. Each section captures every line from the text in a clear, comprehensive, and properly aligned paragraph format, ensuring all details are included.

---

### Project Summary: Understanding the Authentication Flow
The project aims to authenticate users by retrieving their credentials from a PostgreSQL database, specifically from a table named `users` with columns for `id`, `username`, and `password`. To achieve this, the default authentication mechanism in Spring Security is modified by implementing a custom authentication provider. The `DaoAuthenticationProvider` is used, as it facilitates database access for authentication. This provider requires a `UserDetailsService` to fetch user data, which is implemented in a class named `MyUserDetailsService`. This class implements the `UserDetailsService` interface, providing the `loadUserByUsername` method to retrieve user data. Since the data comes from a database, a repository layer, `UserRepo`, is created, extending `JpaRepository` to query the database using a `findByUsername` method. If a user is found, their details are returned; otherwise, a `UsernameNotFoundException` is thrown. To comply with Spring Security’s requirements, the `User` entity is wrapped in a `UserPrincipal` class, which implements the `UserDetails` interface. The `UserPrincipal` represents the current user (principal) and provides methods for retrieving the username, password, and authorities, as well as account status checks (e.g., expiration, locking), though these are currently hardcoded to `true`. The `User` entity, annotated as an `@Entity`, maps to the `users` table, with properties corresponding to the table’s columns. Additional configurations include specifying PostgreSQL connection details in the `application.properties` file and enabling JPA and `Data JPA` dependencies in the `pom.xml` file. While the application is secured, passwords are stored in plain text, which is insecure and requires improvement.

### Introduction to Bcrypt for Password Security
The project successfully stores and validates user credentials in the database using Spring Security, with minimal logic files (`HelloController` and `StudentController`) compared to configuration files for security. In a larger application, logic files would dominate, but configuration files remain limited. However, a significant issue is that passwords are stored and transmitted in plain text, posing a security risk. To address this, cryptography is introduced, specifically focusing on encryption and hashing. Encryption involves encoding a password with a key and decrypting it for verification, but this is vulnerable if the key is compromised. Hashing, a one-way process, is preferred, as it generates a unique hash for each input without the possibility of reverse-engineering the original password. When a user enters a password, it is hashed and compared to the stored hash. Common hashing algorithms include MD5 and SHA-256, but for enhanced security, multiple hashing rounds are desirable. Bcrypt is introduced as a robust algorithm that performs hashing over multiple rounds (e.g., 2^10 or 2^12 rounds), making it computationally intensive and resistant to brute-force attacks. To demonstrate, a Bcrypt password generator website is used, where a password like `h@123` is encoded with 10 or 12 rounds, producing a string starting with `$2a` (indicating the Bcrypt version) and `$10` or `$12` (indicating the number of rounds). This encoded format ensures passwords are secure even if the database is compromised.

### Implementing User Registration
To enable user registration, a new `UserController` is created in the `controllers` package, annotated as `@RestController`. This controller defines a `POST` endpoint at `/register`, which accepts a `User` object via a `@RequestBody` and returns the created user. The `User` entity is used to represent the user data. To handle the registration logic, a `UserService` class is created in the `service` package, annotated with `@Service`. This class includes a `saveUser` method that accepts a `User` object and saves it to the database using the existing `UserRepo`, which is autowired and provides a `save` method. The `UserController` autowires the `UserService` and calls `saveUser` to persist the user data. The application is tested using Postman, with an HTTP `POST` request to `/register`, including headers for authorization (using an existing user, e.g., `hirsch` with password `h@123`). A new user (e.g., `naveen`, password `n@35345`) is sent in the request body. Initially, a wrong authorization password is tested, resulting in a 401 error, but the correct password yields a 200 response with the stored user data. The database is queried to confirm the new user’s presence, validating the registration process. Bcrypt encoding is not yet implemented but will be addressed next.

### Implementing Bcrypt Encoding for User Registration
To secure user passwords during registration, Bcrypt encoding is implemented in the `UserService`. Before saving a user, the plain-text password is encoded using `BCryptPasswordEncoder`, which is part of Spring Security, requiring no additional dependencies. In the `saveUser` method, a `BCryptPasswordEncoder` is instantiated with a strength of 12 (matching the 2^12 rounds used in earlier examples). The user’s plain-text password is retrieved using `user.getPassword()`, encoded with `encoder.encode()`, and set back to the user object using `user.setPassword()`. For debugging, the encoded password is printed to the console, though this is not recommended in production. The registration process is tested again in Postman, creating a new user (e.g., `avni`, password `a@123`). The request succeeds, and the encoded password is visible in the console and database, confirming that the password is stored in Bcrypt format. However, authentication still uses plain-text passwords, as the `DaoAuthenticationProvider` is configured with `NoOpPasswordEncoder`, which must be updated to support Bcrypt.

### Configuring Bcrypt for Authentication
To enable Bcrypt-based authentication, the `SecurityConfig` is updated, specifically the `DaoAuthenticationProvider` configuration. Previously, the provider used `NoOpPasswordEncoder`, which allowed plain-text password comparisons. This is replaced with `new BCryptPasswordEncoder(12)` to ensure passwords are verified using Bcrypt with 12 rounds, matching the encoding strength used during registration. No other changes are required, as the existing `UserDetailsService` and `UserPrincipal` already handle user retrieval and validation. The application is restarted, and authentication is tested in Postman by sending a request to the `/hello` endpoint. Using a plain-text password user (e.g., `hirsch`, `h@123`) fails, as the database stores plain-text passwords incompatible with Bcrypt. However, using a Bcrypt-encoded user (e.g., `avni`, `a@123`) succeeds, confirming that Bcrypt authentication works. To fully transition, plain-text password records (e.g., `hirsch`) are removed, and only Bcrypt-encoded records (e.g., `avni`, `naveen`) are retained. The database is updated manually using an SQL `UPDATE` query to encode existing passwords (e.g., `n@35345` for `naveen`) with Bcrypt, ensuring consistency.

### Key Considerations and Best Practices
The implementation demonstrates a secure approach to password storage and authentication using Bcrypt. The `UserController` remains unaware of encoding, as the `UserService` handles password encoding, maintaining separation of concerns. The `DaoAuthenticationProvider` uses the same Bcrypt strength (12 rounds) for both registration and authentication to ensure compatibility. Using different strengths (e.g., 10 rounds for encoding, 12 for verification) would cause authentication failures. While the project is now more secure, further enhancements could include dynamic role management, account status checks, and additional security measures like HTTPS for data transmission. The configuration files, though numerous, are limited compared to potential logic files in a larger application, making the setup scalable and maintainable.

---

This explanation converts every line from the provided text into a properly aligned paragraph format, organized under relevant headings. Each section ensures clarity, coherence, and completeness, capturing all details from the project summary, Bcrypt introduction, user registration, Bcrypt encoding, and authentication setup.